import numpy as npimport matplotlib.pyplot as pltdef CR(A):        l, c = np.shape(A)        # Centrage    u = np.ones((l, 1))    M = 1/l*(u@u.T@A)    Ac = A - M        #Réduction    D = np.zeros((c, c))    for i in range(c):        Di = 1/np.linalg.norm(Ac[:, i])        D[i, i] = Di    Acr = Ac@D        return Acrdef centre_red(R):        Rcr = CR(R)        return Rcrdef approx(R, k):        Rcr = centre_red(R)        val, vect = np.linalg.eigh(Rcr.T@Rcr)    lambdai = np.argsort(val)[::-1]    vect = -vect[:, lambdai]        V_k = vect[:, :k]        proj_R = Rcr@V_k        return V_k, proj_Rdef ACP2D(R, label_ligne, label_colonne, axes=(1, 2)):    """    Réalise une ACP et représente :      - Un camembert de la variance EXPLIQUEE par TOUS les axes      - Un nuage de points selon les DEUX axes choisis (par défaut axes 1 et 2).    Paramètres    ----------    R : np.array        Tableau (observations x variables)    label_ligne : list ou array        Liste de libellés pour nommer les axes du camembert (ou composantes)        si on veut (sinon on peut générer un label automatique).    label_colonne : list ou array        Label/catégorie de chaque observation, utilisé pour la couleur du scatter plot.    axes : tuple        Paires d'axes à projeter en 2D, ex. (1, 2), (1, 3)...        Notation 1-based, on convertit en indices Python 0-based.    """    # -- On centre/réduit    Rcr = centre_red(R)        # -- Calcul ACP (valeurs propres, vecteurs propres)    val, vect = np.linalg.eigh(Rcr.T @ Rcr)        # Tri décroissant    idx_sorted = np.argsort(val)[::-1]    val = val[idx_sorted]    vect = -vect[:, idx_sorted]        # Pourcentage de variance    val_percent = 100 * val / np.sum(val)        # Nombre total de composantes    nb_comp = len(val)        # Indices pour projeter (conversion 1-based -> 0-based)    ax1, ax2 = axes[0] - 1, axes[1] - 1        # Projection sur TOUS les axes (pour le camembert)    # (on pourrait se limiter à n axes, mais on veut le camembert global)    # ...        # On va créer deux sous-figures : le camembert + le scatter plot    plt.figure(figsize=(12, 6))        # -- Sous-figure 1 : Camembert de la variance sur l'ensemble des composantes    plt.subplot(1, 2, 1)    plt.pie(        val / np.sum(val),        labels=label_ligne,        autopct='%1.1f%%',        startangle=90    )    plt.title('Répartition de la variance expliquée (tous axes)')        # -- Sous-figure 2 : Nuage de points selon les axes choisis    # On projette Rcr sur vect[:, ax1] et vect[:, ax2]    # Projection    W_2D = vect[:, [ax1, ax2]]  # matrice des vecteurs propres correspondant aux 2 axes choisis    proj_R = Rcr @ W_2D        plt.subplot(1, 2, 2)        groupes = np.unique(label_colonne)        # On récupère un colormap (ici tab20) et on échantillonne le nombre de couleurs    # en fonction du nombre de groupes    cmap = plt.cm.get_cmap('tab20', len(groupes))  # ou 'tab10', 'hsv', 'Set3', etc.        # On itère sur les groupes    for i, g in enumerate(groupes):        subset = (label_colonne == g)        # On récupère la couleur i dans la palette        c = cmap(i)        plt.scatter(            proj_R[subset, 0],            proj_R[subset, 1],            label=str(g),            alpha=0.7,            c=[c]  # c doit être un iterable de couleurs        )    plt.legend(        loc='center left',          # Position de référence (le "côté gauche" du cadre de la légende)        bbox_to_anchor=(1.0, 0.5)   # Coordonnées dans l’espace de la figure    )    plt.axhline(0, color='gray', linewidth=0.8, linestyle='--')    plt.axvline(0, color='gray', linewidth=0.8, linestyle='--')    plt.xlim(-1.1, 1.1)    plt.ylim(-1.1, 1.1)    plt.axis('equal')        # Intitulé des axes, avec le % de variance si pertinent    plt.title('Projection des données (ACP)')    plt.xlabel(f'$v_{axes[0]}^T$ (taux explicatif = {val_percent[ax1]:.1f}%)')    plt.ylabel(f'$v_{axes[1]}^T$ (taux explicatif = {val_percent[ax2]:.1f}%)')    plt.grid(alpha=0.3)        plt.tight_layout()    plt.show()def Cercle_corr2D(R, labels_colonne, axes=(1, 2)):    """    Représente le cercle de corrélations pour les deux axes spécifiés (axes=(1,2) par défaut).    """    Rcr = centre_red(R)    val, vect = np.linalg.eigh(Rcr.T @ Rcr)        # Tri décroissant    idx_sorted = np.argsort(val)[::-1]    val = val[idx_sorted]    vect = -vect[:, idx_sorted] # on ajoute un moins afin de se retrouver dans la même configuration que dans l'exemple donnée dans le BE        # Indices 0-based    ax1, ax2 = axes[0] - 1, axes[1] - 1        # On prend les vecteurs propres correspondant aux axes voulus    V_k = vect[:, [ax1, ax2]]        # Projection sur ces deux axes    proj_R = Rcr @ V_k        p = Rcr.shape[1]    cor = np.zeros((p, 2))    for i in range(p):        for j in range(2):            # corrélation variable i / axe j            cor[i, j] = np.corrcoef(Rcr[:, i], proj_R[:, j])[0, 1]        plt.figure(figsize=(6, 6))    plt.axhline(0, color='gray', linewidth=0.8, linestyle='--')    plt.axvline(0, color='gray', linewidth=0.8, linestyle='--')        cercle = plt.Circle((0, 0), 1, color='red', fill=False, linestyle='--')    plt.gca().add_artist(cercle)        # on corrige la longueur de la flèche pour plus de clarté        for i, (x, y) in enumerate(cor):        r = np.sqrt(x**2 + y**2)        delta = 0.05        if r > delta:            alpha = (r - delta) / r            x_new = alpha * x            y_new = alpha * y        else:            x_new, y_new = x, y                plt.arrow(            0, 0,            x_new, y_new,            head_width=0.03,            head_length=0.05,            fc='blue', ec='blue', alpha=0.5        )        plt.text(x, y, labels_colonne[i], fontsize=10, ha='center', va='center')        plt.xlim(-1.1, 1.1)    plt.ylim(-1.1, 1.1)    plt.title("Cercle des corrélations")    plt.xlabel(f"Projection sur $P_{axes[0]}$")    plt.ylabel(f"Projection sur $P_{axes[1]}$")    plt.grid(alpha=0.3)    plt.show()